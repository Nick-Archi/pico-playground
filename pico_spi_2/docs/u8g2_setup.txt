My Notes on setting up & utilizing u8g2 in my SPI project

Links:
[] U8g2 Tutorial: https://github.com/olikraus/u8g2/wiki/setup_tutorial
[] u8g2setupc: https://github.com/olikraus/u8g2/wiki/u8g2setupc
	-- there are introduction steps for setting up a C project
	-- this is the setup function I will try to use: u8g2_Setup_sh1106_128x64_noname_f(u8g2, rotation, u8x8_byte_4wire_sw_spi, uC specific) [full framebuffer, size = 1024 bytes]
		-- u8g2/csrc/u8g2.h:758:void u8g2_Setup_sh1106_128x64_noname_f(u8g2_t *u8g2, const u8g2_cb_t *rotation, u8x8_msg_cb byte_cb, u8x8_msg_cb gpio_and_delay_cb);


Notes regarding u8g2_Setup_sh1106_128x64_noname_f parameters:
[] u8g2 -> structure for u8g2 definitions
[] rotation -> Macro defintion defining the orientation of the OLED
[] u8x8_msg_cb -> function pointer to send message via SPI
	-- u8g2/csrc/u8x8.h:215:typedef uint8_t (*u8x8_msg_cb)(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr);
	-- examples @: 
		-- u8g2/csrc/u8x8.h:705:uint8_t u8x8_byte_sw_i2c(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr);
		-- u8g2/csrc/u8x8_byte.c:578:uint8_t u8x8_byte_sw_i2c(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)

[] u8x8_msg_cb -> function pointer to control GPIO pins for CS, DC, and RST

[] There's some code that you can follow that I think will give you an idea of what to do?
	-- u8g2/csrc/u8x8_byte.c:107:uint8_t u8x8_byte_4wire_sw_spi(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)


[] I tried calling my functions to initialize the SPI configuration and then the SH1106. Afterwards calling u8g2_Setup_sh1106_128x64_noname_f(), u8g2_ClearBuffer(), u8g2_DrawStr(), and u8g2_SendBuffer, but nothing appears on the screen. 
	-- Trying to trace what's going on in the line of execution....

Type Notes:	
[] u8g2_t(typedef struct u8g2_struct) is defined in, u8g2/csrc/u8g2.h:219
[] u8x8_t is defined in, u8g2/csrc/u8x8.h:211
	
[] u8g2_Setup_sh1106_128x64_noname_f(), u8g2/csrc/u8g2_d_setup.c:662
{
// inside u8g2_Setup_sh1106_128x64_noname_f()
-- allocates uint8_t tile_buf_height & uint8_t* buf
-- calls u8g2_SetupDisplay(u8g2, u8x8_d_sh1106_128x64_noname, u8x8_cad_001, byte_cb, gp     io_and_delay_cb);

	-- u8g2_SetupDisplay seems to be a macro for u8x8_Setup() see u8g2/csrc/u8g2.h:402
	*** NOTE, #define u8g2_SetupDisplay(u8g2, display_cb, cad_cb, byte_cb, gpio_and_delay_cb) \ u8x8_Setup(u8g2_GetU8x8(u8g2), (display_cb), (cad_cb), (byte_cb), (gpio_and_deay_cb))
	*** u8g2_GetU8x8(), u8g2/csrc/u8g2.h:388, will cast the u8g2 into a (u8x8_t*)
		*** u8g2_t does have a u8x8_t defined as the first variable...so I guess this works fine...
		
	-- u8g2/csrc/u8x8_setup.c:133:void u8x8_Setup(u8x8_t *u8x8, u8x8_msg_cb display_cb, u8x8_msg_cb cad_cb, u8x8_msg_cb byte_cb, u8x8_msg_cb gpio_and_delay_cb)
	{
		// inside call to u8g2_SetupDisplay() {u8x8_Setup()}
		-- calls u8x8_SetupDefaults(), u8g2/csrc/u8x8_setup.c:95
		{
			// inside u8x8_SetupDefaults()
			-- seems to just assign default values to the u8x8(u8g2) struct
		} // exit u8x8_SetupDefaults()
		
		-- overwrites some of the defaulted values in the u8x8 struct
		
		-- calls u8x8_SetupMemory(), u8g2/csrc/u8x8_display.c:93
		{
			// inside u8x8_SetupMemory
			-- this seems to call u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_SETUP_MEMORY, 0, NULL);
			-- calling a function pointer (func) to setup the memory for the display?
			-- so because u8x8->display_cb will be pointing to this function, u8x8_d_sh1106_128x64_noname, call it...
			{
				// inside u8x8_d_sh1106_128x64_noname, u8g2/csrc/u8x8_d_ssd1306_128x64_n
oname.c:479
				-- case for U8X8_MSG_DISPLAY_SETUP_MEMORY
				-- call u8x8_d_helper_display_setup_memory(u8x8, &u8x8_sh1106_128x64_noname_display_info);
					-- u8x8_sh1106_128x64_noname_display_info: u8g2/csrc/u8x8_d_ssd1306_128x64_noname.c:455:static const u8x8_display_info_t u8x8_sh1106_128x64_noname_display_info =
				-- u8x8_d_helper_display_setup_memory() defined u8g2/csrc/u8x8.h:436 & u8g2/csrc/u8x8_display.c:52
				{
					// inside u8x8_d_helper_display_setup_memory()
					** so I'm pretty confused by which u8x8_d_helper_display_setup_memory() will be called
					** b/c there's so many defined I'm going to assume that it's the one in u8g2/csrc/u8x8_d_ssd1306_128x64_noname.c
						***** Why is the ssh1106 using this ssd1306 is beyond my understanding rn
						
					-- set's u8x8->display_info and u8x8->x_offset
				} // end u8x8_d_helper_display_setup_memory()
			} // end u8x8?d_sh1106_128x64_noname
		}// end u8x8_SetupMemory
	} // end of SetupDisplay {u8x8_Setup}
	
	-- u8g2/csrc/u8g2_d_setup.c:667, call u8g2_m_16_8_f(&tile_buf_height);
	{
		// entering u8g2/csrc/u8g2_d_memory.c:61
		-- this seems to assign the allocation for the buffer 
	} //exit 
	
	-- call u8g2_SetupBuffer(u8g2, buf, tile_buf_height, u8g2_ll_hvline_vertical_top_lsb,rotation)
	-- defined @ u8g2/csrc/u8g2.h:461 & u8g2/csrc/u8g2_setup.c:71
	{
		// inside u8g2_SetupBuffer
		-- this seems to setup the rest of the u8g2 struct
		** the buffer that was allocated previously in u8g2_m_16_8_f() is assigned to the u8g2 struct
	} // exit u8g2_SetupBuffer
	
} // end of u8g2_Setup_sh1106_128x64_noname_f()

-- executing u8g2_ClearBuffer(&u8g2)
-- defined @ u8g2/csrc/u8g2.h:1728 implemented @ u8g2/csrc/u8g2_buffer.c:40
{
	// inside u8g2_ClearBuffer
	-- using memset to clear the u8g2.tile_buf_ptr
} // exit u8g2_ClearBuffer

-- executing u8g2_DrawStr();
-- defined @ u8g2/csrc/u8g2.h:1912 implemented @ u8g2/csrc/u8g2_font.c:1039
{
	// inside u8g2_DrawStr()
	-- asigns u8g2->u8x8.next_cb to u8x8_ascii_next
		-- u8x8_ascii_next is defined @ u8g2/csrc/u8x8.h:1073 & implemented @ u8g2/csrc/u8x8_8x8.c:290

	-- calls u8g2_draw_string(u8g2, x, y, str);
	u8g2_draw_string defined @ implemented @ u8g2/csrc/u8g2_font.c:967
	{
		// entering u8g2_draw_string
		-- sets up some variables
		-- calls u8x8_utf8_init(u8g2_GetU8x8(u8g2));
		-- u8x8_utf8_init() defined @ implemented @ u8g2/csrc/u8x8_8x8.c:285
		{
			// entering u8x8_utf8_init
			-- sets u8x8->utf8_state to 0
		} // exiting u8x8_utf8_init
		
		-- enter for loop
		-- call u8g2->u8x8.next_cb which points to u8x8_ascii_next()
		{
			// enter u8g2->u8x8.next_cb
			[TODO] Investigate?
		} // exit u8x8_ascii_next()
		
		-- break if the return was new line?
		-- otherwise increment the pointer to move to next char
		
		-- if the return (e) doesn't equal 0x0fffe then...
		-- call u8g2_DrawGlyph(u8g2, x, y, e)
			-- u8g2_DrawGlyph defined @ u8g2/csrc/u8g2.h:1905 implemented @ u8g2/csrc/u8g2_font.c:936
		{
			[TODO] explore?
			
			-- calls u8g2_font_draw_glyph
			-- u8g2_font_draw_glyph defined @ implemented @ u8g2/csrc/u8g2_font.c:869
			{
			
			} // exit u8g2_font_draw_glyph
		} // exit u8g2_DrawGlyph
		
		[TODO] I don't want to explore this...
	} // exiting u8g2_draw_string
	
} // exit u8g2_DrawStr

-- call u8g2_SendBuffer(&u8g2)
-- defined @ u8g2/csrc/u8g2.h:1727 implemented @ u8g2/csrc/u8g2_buffer.c:93
{
	// entering u8g2_SendBuffer
	-- call u8g2_send_buffer(u8g2)
	-- defined @ implemented @ u8g2/csrc/u8g2_buffer.c:72
	{
		// entering u8g2_send_buffer
		-- set variables & call u8g2_GetU8x8()
		-- eventually call u8x8_DrawTile(u8g2_GetU8x8(u8g2), 0, dest_tile_row, w, ptr)
			-- u8x8_DrawTile defined @ implemented @ u8g2/csrc/u8x8_display.c:82
			{
			
			} // exit u8x8_DrawTile
		[TODO] possibly explore this? 
	} // exiting u8g2_send_buffer
	
	-- call u8x8_RefreshDisplay(u8g2_GetU8x8(u8g2))
	-- defined @ implemented @ u8g2/csrc/u8x8_display.c:156
	{
		// entering u8x8_RefreshDisplay
		-- call u8x8->display_cb(u8x8, U8X8_MSG_DISPLAY_REFRESH, 0, NULL)
- so because u8x8->display_cb will be pointing to this function, u8x8_d_sh1106_128x64_noname, call it...
		{
			// inside u8x8_d_sh1106_128x64_noname, u8g2/csrc/u8x8_d_ssd1306_128x64_noname.c:479	
		} // exit u8x8_d_sh1106_128x64_noname	
	} // exit u8x8_ReferestDisplay
	
} // exiting u8g2_SendBuffer

[] 4/4/25, this tracing is near impossible...I either have to take another approach or find a way to run a debugger attached

[] 4/30/25, Back baby! And this time I got some help! Able to setup OpenOCD to debug this crap.
Useful things I learned:
    [] Set up a logging file so that output from GDB is redirected
        -- Open new terminal
        -- execute, tty
        -- within terminal reunning gdb
        -- execute, tui enable
        -- execute, set logging file <output-frm-tty>
        -- execute, set logging on
        -- now execute, display <variable> and output will show on terminal
        
    [] Tail the log file:
        -- within gdb, execute, set logging file <file-name>
        -- execute, set logging enable on
        -- execute, display <var>
        
        -- in another terminal
        -- execute, tail -f <file-name>
        
        
[] Getting back into this but...how was the u8g2 library built again? It seems that I may have to build this with debug flags enabled because I am not able to break into intended functions

[] Building spi project
       -- run cmake -DCMAKE_BUILD_TYPE=Debug .. 2>&1 | tee debug_build_output.txt
            -- Google for more optimization flags
            -- turning off optimizations for RP2350, https://forums.raspberrypi.com/viewtopic.php?t=376453
                -- ie) cmake -DCMAKE_BUILD_TYPE=Debug -DPICO_DEOPTIMIZED_DEBUG=ON .. 2>&1 | tee debug_build_output.txt
        -- run make 2>&1|tee make_debug_build_output.txt    

[] Rebuilding u8g2 library
    [] Clone u8g2 from repo
        -- execute the respective git clone command to clone this into the directory for the spi_2 proj
        -- modifiy the CMakeLists.txt to use the ARM COrtex M33 compiler
            -- add this line:
            # Build with ARM Cortex M33 compiler
            set(CMAKE_TOOLCHAIN_FILE $ENV{PICO_SDK_PATH}/cmake/preload/toolchains/pico_arm_cortex_m33_gcc.cmake)
            
    [] Building u8g2 for debug
        -- create debug folder in u8g2 directory
        -- run cmake -DCMAKE_BUILD_TYPE=Debug .. 2>&1 | tee debug_build_output.txt
            -- Google for more optimization flags
            -- turning off optimizations for RP2350, https://forums.raspberrypi.com/viewtopic.php?t=376453
                -- ie) cmake -DCMAKE_BUILD_TYPE=Debug -DPICO_DEOPTIMIZED_DEBUG=ON .. 2>&1 | tee debug_build_output.txt
        -- run make 2>&1|tee make_debug_build_output.txt
        -- run make install

[] Steps to setting up debugging environment:
    [] Start OpenOCD
        -- sudo openocd -d -f interface/raspberrypi-swd.cfg -f target/rp2350.cfg
    [] Setup GDB
        -- gdb <target>.elf
        -- target remote localhost:3333
        -- monitor reset init
        -- load
        -- tui enable ** switch to command window, enter 'focus cmd'
        -- set logging file <file-name-path>
        -- set logging enable on
    [] Debugging Issues:
    [] Disconnecting from Target
        -- in gdb, execute monitor reset halt
        -- OR, to continue having it run, execute monitor reset run
    
    
[] Back to debugging
    -- I am noticing an issue when executing u8g2_SendBuffer call in spi_main.c
    -- Here's the stack trace:
        -- u8x8_spi_send_data, u8x8_byte_SetDC, u8x8_cad_001, u8x8_cad_SendCmd, u8x8_d_ssd1306_sh1106_generic, u8x8_d_sh1106_128x64_noname, u8x8_DrawTile, u8g2_send_tile_row, u8g2_send_buffer, u8g2_SendBuffer, main

        -- I think there's an issue with the u8x8_spi_send_data() , it doesn't seem like the switch handles all the cases
            -- ie) msg set to U8X8_MSG_BYTE_SET_DC, but in function, switch doesn't handle this...
        -- probably need to figure out what macros are missing and add to switch
        -- take a look at u8x8.h:602 for hints?
            -- also u8x8.h:681 ???
            
    -- I think a lot of my issues are stemming from the u8x8_spi_send_data() in sh1106_Interactions.c...
        -- I need to figure out what all of the U8X8_MSG_CAD_* macros are doing and what handlers need to be created from them...
